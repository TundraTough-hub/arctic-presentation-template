#!/usr/bin/env node\n\n/**\n * Animation-Accurate Arctic Background Exporter\n * With adjustable animation speed control\n */\n\nconst puppeteer = require('puppeteer');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Configuration with animation speed control\nconst CONFIG = {\n  // Video settings\n  duration: 12000, // 12 seconds in milliseconds\n  fps: 30,\n  \n  // Animation speed settings\n  animationSpeed: 1.0, // 1.0 = normal, 0.5 = half speed, 2.0 = double speed\n  \n  // Resolution options\n  resolutions: {\n    hd: { width: 1280, height: 720, name: 'HD' },\n    fhd: { width: 1920, height: 1080, name: 'Full HD' },\n    uhd: { width: 3840, height: 2160, name: '4K UHD' },\n    presentation: { width: 1366, height: 768, name: 'Presentation' }\n  },\n  \n  // Default resolution\n  defaultResolution: 'fhd',\n  \n  // Output directories\n  outputDir: './mp4-backgrounds-accurate',\n  screenshotDir: './temp-screenshots-accurate',\n  \n  // File paths\n  baseDir: '../',\n  \n  // Animation timing settings\n  quality: 'high',\n  frameInterval: 1000 / 30, // 33.33ms for 30fps - video framerate stays constant\n  imageFormat: 'jpeg',\n  imageQuality: 95,\n  \n  // Animation synchronization\n  animationResetDelay: 2000,\n  captureDelay: 16,\n};\n\n// Quality presets for ffmpeg\nconst QUALITY_PRESETS = {\n  low: { crf: 28, preset: 'fast' },\n  medium: { crf: 23, preset: 'medium' },\n  high: { crf: 18, preset: 'slow' },\n  ultra: { crf: 15, preset: 'veryslow' }\n};\n\nclass AnimationAccurateExporter {\n  constructor() {\n    this.setupDirectories();\n    this.slides = this.defineAllSlides();\n  }\n\n  setupDirectories() {\n    const dirs = [\n      CONFIG.outputDir,\n      CONFIG.screenshotDir,\n      path.join(CONFIG.outputDir, 'classic'),\n      path.join(CONFIG.outputDir, 'modern'),\n      path.join(CONFIG.outputDir, 'stills')\n    ];\n\n    dirs.forEach(dir => {\n      fs.ensureDirSync(dir);\n    });\n\n    console.log('üìÅ Directory structure ready');\n  }\n\n  defineAllSlides() {\n    return [\n      // Classic Arctic slides\n      {\n        file: 'slides/slide-01-title.html',\n        name: 'arctic-title-classic',\n        category: 'classic',\n        description: 'Classic Arctic title slide with flowing background elements',\n        type: 'title'\n      },\n      {\n        file: 'slides/slide-02-section-divider.html',\n        name: 'arctic-section-classic',\n        category: 'classic',\n        description: 'Classic section divider with wave animation',\n        type: 'section'\n      },\n      {\n        file: 'slides/slide-03-data-insights.html',\n        name: 'arctic-data-classic',\n        category: 'classic',\n        description: 'Classic data visualization background',\n        type: 'data'\n      },\n      \n      // Modern Arctic slides\n      {\n        file: 'slides/slide-modern-01-title.html',\n        name: 'arctic-title-modern',\n        category: 'modern',\n        description: 'Modern minimalist title slide with subtle animations',\n        type: 'title'\n      },\n      {\n        file: 'slides/slide-modern-02-data.html',\n        name: 'arctic-data-modern',\n        category: 'modern',\n        description: 'Modern data background with clean geometric elements',\n        type: 'data'\n      },\n      {\n        file: 'slides/slide-modern-03-section.html',\n        name: 'arctic-section-modern',\n        category: 'modern',\n        description: 'Modern section divider with contemporary design',\n        type: 'section'\n      }\n    ];\n  }\n\n  async exportAllBackgrounds() {\n    console.log('üé¨ Starting Animation-Speed-Controlled Arctic Background Export\\n');\n    console.log(`üìä Exporting ${this.slides.length} slide backgrounds`);\n    console.log(`üéØ Resolution: ${CONFIG.resolutions[CONFIG.defaultResolution].name}`);\n    console.log(`‚è±Ô∏è  Duration: ${CONFIG.duration / 1000}s per background`);\n    console.log(`üéûÔ∏è  Frame Rate: ${CONFIG.fps} fps (constant video framerate)`);\n    \n    // Animation speed info\n    const speedText = this.getAnimationSpeedText(CONFIG.animationSpeed);\n    console.log(`üé® Animation Speed: ${speedText}`);\n    console.log('');\n\n    let browser;\n    try {\n      // Check dependencies first\n      this.checkDependencies();\n      \n      // Launch browser\n      browser = await this.launchBrowser();\n      \n      // Export all slides\n      for (const slide of this.slides) {\n        await this.exportSingleSlideBackground(browser, slide);\n      }\n      \n      // Create usage guide\n      this.createUsageGuide();\n      \n      console.log('\\n‚úÖ Animation-speed-controlled background export complete!');\n      console.log(`üìÅ Check ${CONFIG.outputDir} for all exported backgrounds`);\n      \n    } catch (error) {\n      console.error('‚ùå Export failed:', error.message);\n      this.logTroubleshootingInfo();\n    } finally {\n      if (browser) await browser.close();\n      \n      // Clean up temporary files\n      this.cleanup();\n    }\n  }\n\n  getAnimationSpeedText(speed) {\n    if (speed === 1.0) return '1.0x (Normal speed)';\n    if (speed < 1.0) return `${speed}x (Slower - more relaxed)`;\n    return `${speed}x (Faster - more energetic)`;\n  }\n\n  checkDependencies() {\n    console.log('üîç Checking dependencies...');\n    \n    try {\n      // Check if ffmpeg is available\n      try {\n        execSync('ffmpeg -version', { stdio: 'pipe' });\n        console.log('‚úÖ System FFmpeg found');\n      } catch (error) {\n        // Try to use ffmpeg-static\n        const ffmpegStatic = require('ffmpeg-static');\n        if (ffmpegStatic) {\n          console.log('‚úÖ Using ffmpeg-static');\n          process.env.FFMPEG_PATH = ffmpegStatic;\n        } else {\n          throw new Error('FFmpeg not found. Please install ffmpeg or ffmpeg-static.');\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Dependency check failed:', error.message);\n      throw error;\n    }\n  }\n\n  async launchBrowser() {\n    console.log('üöÄ Launching browser with animation optimization...');\n    return await puppeteer.launch({\n      headless: 'new',\n      args: [\n        '--no-sandbox',\n        '--disable-setuid-sandbox',\n        '--disable-dev-shm-usage',\n        '--disable-web-security',\n        '--allow-running-insecure-content',\n        '--disable-features=VizDisplayCompositor',\n        '--enable-gpu-rasterization',\n        '--enable-oop-rasterization'\n      ]\n    });\n  }\n\n  async exportSingleSlideBackground(browser, slide) {\n    console.log(`üé• Exporting ${slide.name} (${slide.category})...`);\n    \n    const page = await browser.newPage();\n    const resolution = CONFIG.resolutions[CONFIG.defaultResolution];\n    \n    // Configure page for accurate animation capture\n    await page.setViewport({\n      width: resolution.width,\n      height: resolution.height,\n      deviceScaleFactor: 1\n    });\n\n    // Disable throttling to ensure accurate timing\n    const client = await page.target().createCDPSession();\n    await client.send('Emulation.setCPUThrottlingRate', { rate: 1 });\n\n    const slideFile = path.resolve(CONFIG.baseDir, slide.file);\n    const screenshotFolder = path.join(CONFIG.screenshotDir, slide.name);\n    const speedSuffix = CONFIG.animationSpeed === 1.0 ? '' : `-${CONFIG.animationSpeed}x`;\n    const outputFile = path.join(CONFIG.outputDir, slide.category, `${slide.name}-background${speedSuffix}.mp4`);\n\n    try {\n      // Check if slide file exists\n      if (!fs.existsSync(slideFile)) {\n        throw new Error(`Slide file not found: ${slideFile}`);\n      }\n\n      // Create screenshot folder\n      fs.ensureDirSync(screenshotFolder);\n\n      // Load slide\n      console.log(`   Loading: ${slide.file}`);\n      await page.goto(`file://${slideFile}`, { waitUntil: 'networkidle0' });\n      \n      // Wait for everything to load and prepare animations\n      await this.waitForSlideReady(page);\n      \n      // Prepare background for recording and set animation speed\n      await this.prepareBackgroundElements(page, slide.type);\n      \n      // Synchronize animations with custom speed\n      await this.synchronizeAnimations(page);\n      \n      // Capture frames with accurate timing\n      console.log(`   Capturing ${Math.ceil(CONFIG.duration / CONFIG.frameInterval)} frames (${CONFIG.animationSpeed}x animation speed)...`);\n      await this.captureAnimationFrames(page, screenshotFolder);\n      \n      // Convert screenshots to video using ffmpeg\n      console.log(`   Converting to MP4 with original timing...`);\n      await this.createVideoFromScreenshots(screenshotFolder, outputFile);\n      \n      // Create still frame\n      await this.createStillFrame(page, slide);\n      \n      // Get file stats\n      if (fs.existsSync(outputFile)) {\n        const stats = fs.statSync(outputFile);\n        const sizeMB = (stats.size / (1024 * 1024)).toFixed(1);\n        const speedText = CONFIG.animationSpeed === 1.0 ? '' : ` (${CONFIG.animationSpeed}x speed)`;\n        console.log(`‚úÖ Exported ${slide.name} (${sizeMB} MB)${speedText}`);\n      }\n      \n    } catch (error) {\n      console.error(`‚ùå Failed to export ${slide.name}:`, error.message);\n    } finally {\n      await page.close();\n      \n      // Clean up screenshots for this slide\n      try {\n        fs.removeSync(screenshotFolder);\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n  }\n\n  async waitForSlideReady(page) {\n    // Wait for DOM ready\n    await page.waitForFunction(() => document.readyState === 'complete');\n    \n    // Wait for fonts and CSS to load\n    await page.waitForTimeout(3000);\n    \n    // Wait for web fonts specifically\n    try {\n      await page.evaluate(() => {\n        return document.fonts.ready;\n      });\n    } catch (e) {\n      // Ignore if fonts API not available\n    }\n    \n    // Additional wait for any lazy-loaded resources\n    await page.waitForTimeout(1000);\n  }\n\n  async synchronizeAnimations(page) {\n    console.log('   Synchronizing animations with speed control...');\n    \n    // Reset all animations to start from the beginning with custom speed\n    await page.evaluate((animationSpeed) => {\n      // Stop all animations\n      const animatedElements = document.querySelectorAll('*');\n      animatedElements.forEach(el => {\n        el.style.animationPlayState = 'paused';\n      });\n      \n      // Force a reflow\n      document.body.offsetHeight;\n      \n      // Apply animation speed multiplier\n      const applyAnimationSpeed = () => {\n        animatedElements.forEach(el => {\n          const computedStyle = getComputedStyle(el);\n          if (computedStyle.animationName && computedStyle.animationName !== 'none') {\n            // Get current animation duration\n            const currentDuration = computedStyle.animationDuration;\n            if (currentDuration && currentDuration !== 'auto') {\n              const durations = currentDuration.split(', ');\n              const adjustedDurations = durations.map(duration => {\n                const timeValue = parseFloat(duration);\n                const unit = duration.replace(timeValue.toString(), '');\n                // Divide by speed to make faster animations (2x speed = half duration)\n                const adjustedTime = timeValue / animationSpeed;\n                return adjustedTime + unit;\n              });\n              el.style.animationDuration = adjustedDurations.join(', ');\n            }\n          }\n        });\n      };\n      \n      // Reset animation start time\n      const resetAnimations = () => {\n        animatedElements.forEach(el => {\n          if (el.style.animation || getComputedStyle(el).animationName !== 'none') {\n            const currentAnimation = el.style.animation;\n            el.style.animation = 'none';\n            el.offsetHeight; // Force reflow\n            el.style.animation = currentAnimation;\n          }\n        });\n      };\n      \n      // Apply speed then reset\n      applyAnimationSpeed();\n      resetAnimations();\n      \n      // Resume animations in sync\n      setTimeout(() => {\n        animatedElements.forEach(el => {\n          el.style.animationPlayState = 'running';\n        });\n      }, 50);\n    }, CONFIG.animationSpeed);\n    \n    // Wait for animations to reset and start\n    await page.waitForTimeout(CONFIG.animationResetDelay);\n  }\n\n  async prepareBackgroundElements(page, slideType) {\n    await page.evaluate(() => {\n      // Hide all text and content elements\n      const hideSelectors = [\n        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span',\n        '.main-title', '.subtitle', '.slide-number', '.slide-type',\n        '.title-section', '.subtitle-section', '.brand-section',\n        '.logo-container', '.logo-text', '.slide-info',\n        '.data-card', '.chart-container', '.text-content',\n        '.card-info', '.card-title', '.card-description',\n        '.accent-line:not(.background-accent)',\n        '.corner-accent:not(.background-corner)',\n        '.content-area', '.text-overlay'\n      ];\n\n      hideSelectors.forEach(selector => {\n        document.querySelectorAll(selector).forEach(el => {\n          el.style.opacity = '0';\n          el.style.visibility = 'hidden';\n        });\n      });\n\n      // Ensure background elements are visible\n      const backgroundSelectors = [\n        '.background-layer', '.slide-container',\n        '.fluid-shape', '.floating-element', '.wave-element',\n        '.organic-shape', '.flow-shape', '.particle',\n        '.primary-flow', '.secondary-flow',\n        '.circle-accent', '.oval-accent',\n        '.decorative-elements', '.animated-bg'\n      ];\n\n      backgroundSelectors.forEach(selector => {\n        document.querySelectorAll(selector).forEach(el => {\n          el.style.visibility = 'visible';\n          el.style.opacity = el.style.opacity || '1';\n        });\n      });\n\n      // Optimize animations for consistent capture\n      const style = document.createElement('style');\n      style.textContent = `\n        * {\n          animation-play-state: running !important;\n          backface-visibility: hidden !important;\n          transform-style: preserve-3d !important;\n          will-change: transform, opacity !important;\n        }\n        \n        body, html {\n          margin: 0 !important;\n          padding: 0 !important;\n          overflow: hidden !important;\n        }\n\n        .slide-container {\n          width: 100vw !important;\n          height: 100vh !important;\n        }\n\n        /* Ensure animations are optimized for capture */\n        .fluid-shape, .floating-element, .organic-shape, .flow-shape {\n          animation-timing-function: linear !important;\n          animation-fill-mode: both !important;\n        }\n      `;\n      document.head.appendChild(style);\n    });\n\n    // Small wait for DOM changes to take effect\n    await page.waitForTimeout(500);\n  }\n\n  async captureAnimationFrames(page, screenshotFolder) {\n    const totalFrames = Math.ceil(CONFIG.duration / CONFIG.frameInterval);\n    const startTime = Date.now();\n    \n    for (let i = 0; i < totalFrames; i++) {\n      const frameTime = Date.now();\n      const filename = path.join(screenshotFolder, `frame_${i.toString().padStart(6, '0')}.${CONFIG.imageFormat}`);\n      \n      // Create screenshot options based on format\n      const screenshotOptions = {\n        path: filename,\n        type: CONFIG.imageFormat,\n        fullPage: false,\n        optimizeForSpeed: false\n      };\n\n      // Only add quality for JPEG format\n      if (CONFIG.imageFormat === 'jpeg') {\n        screenshotOptions.quality = CONFIG.imageQuality;\n      }\n\n      // Capture screenshot\n      await page.screenshot(screenshotOptions);\n      \n      // Calculate how long to wait for next frame (video framerate stays constant)\n      const elapsedTime = Date.now() - frameTime;\n      const targetTime = CONFIG.frameInterval;\n      const waitTime = Math.max(0, targetTime - elapsedTime - CONFIG.captureDelay);\n      \n      if (waitTime > 0) {\n        await page.waitForTimeout(waitTime);\n      }\n      \n      // Show progress\n      if (i % 30 === 0 || i === totalFrames - 1) {\n        const progress = Math.round((i / totalFrames) * 100);\n        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n        process.stdout.write(`\\r   Progress: ${progress}% (${elapsed}s elapsed)`);\n      }\n    }\n    \n    console.log(''); // New line after progress\n  }\n\n  async createVideoFromScreenshots(screenshotFolder, outputFile) {\n    const quality = QUALITY_PRESETS[CONFIG.quality];\n    const inputPattern = path.join(screenshotFolder, `frame_%06d.${CONFIG.imageFormat}`);\n    \n    // Use ffmpeg-static path if available\n    const ffmpegCmd = process.env.FFMPEG_PATH || 'ffmpeg';\n    \n    // Create video with exact frame rate timing (video framerate remains constant)\n    const command = `\"${ffmpegCmd}\" -y -r ${CONFIG.fps} -i \"${inputPattern}\" -c:v libx264 -crf ${quality.crf} -preset ${quality.preset} -pix_fmt yuv420p -movflags +faststart -r ${CONFIG.fps} \"${outputFile}\"`;\n    \n    try {\n      execSync(command, { stdio: 'pipe' });\n    } catch (error) {\n      throw new Error(`FFmpeg failed: ${error.message}`);\n    }\n  }\n\n  async createStillFrame(page, slide) {\n    const stillPath = path.join(CONFIG.outputDir, 'stills', `${slide.name}-still.png`);\n    \n    // Wait for a good animation frame\n    await page.waitForTimeout(2000);\n    \n    await page.screenshot({\n      path: stillPath,\n      type: 'png',\n      fullPage: false\n    });\n    \n    console.log(`üì∏ Created still: ${slide.name}-still.png`);\n  }\n\n  createUsageGuide() {\n    const guide = `# Animation-Speed-Controlled Arctic Presentation Backgrounds\n\n## üìä Export Summary\n\n- **Export Method**: Animation-Synchronized Capture with Speed Control\n- **Total Backgrounds**: ${this.slides.length}\n- **Resolution**: ${CONFIG.resolutions[CONFIG.defaultResolution].name} (${CONFIG.resolutions[CONFIG.defaultResolution].width}√ó${CONFIG.resolutions[CONFIG.defaultResolution].height})\n- **Duration**: ${CONFIG.duration / 1000} seconds each\n- **Format**: MP4 (H.264)\n- **Video Frame Rate**: ${CONFIG.fps} fps (constant)\n- **Animation Speed**: ${this.getAnimationSpeedText(CONFIG.animationSpeed)}\n- **Animation Accuracy**: ‚úÖ CSS timing preserved with speed adjustment\n\n## üìÅ Exported Files\n\n### Classic Arctic Backgrounds (Dynamic & Flowing)\n${this.slides.filter(s => s.category === 'classic').map(s => {\n  const speedSuffix = CONFIG.animationSpeed === 1.0 ? '' : `-${CONFIG.animationSpeed}x`;\n  return `- **${s.name}-background${speedSuffix}.mp4**: ${s.description}`;\n}).join('\\n')}\n\n### Modern Arctic Backgrounds (Clean & Minimal)\n${this.slides.filter(s => s.category === 'modern').map(s => {\n  const speedSuffix = CONFIG.animationSpeed === 1.0 ? '' : `-${CONFIG.animationSpeed}x`;\n  return `- **${s.name}-background${speedSuffix}.mp4**: ${s.description}`;\n}).join('\\n')}\n\n## üé® Animation Speed Control\n\n### How It Works\n- **Video framerate**: Always ${CONFIG.fps} fps (smooth playback)\n- **CSS animation durations**: Modified before capture\n- **Speed ${CONFIG.animationSpeed}x**: ${\n  CONFIG.animationSpeed === 1.0 ? 'Normal speed (original timing)' :\n  CONFIG.animationSpeed < 1.0 ? 'Slower, more relaxed animations' :\n  'Faster, more energetic animations'\n}\n- **File naming**: Includes speed suffix when not 1.0x\n\n### Speed Examples\n- **0.5x**: Half speed - very relaxed, ambient\n- **1.0x**: Normal speed - original design timing\n- **2.0x**: Double speed - energetic, dynamic\n- **3.0x**: Triple speed - very fast, attention-grabbing\n\n## üìä PowerPoint Integration\n\n1. **Design** ‚Üí **Format Background** ‚Üí **Picture or Texture Fill**\n2. Select your MP4 file (note speed suffix in filename)\n3. ‚úÖ Check **Loop** for continuous playback\n4. **Apply to All Slides**\n\n## üí° Use Cases by Speed\n\n### Slower Speeds (0.3x - 0.8x)\n- Meditation/wellness presentations\n- Background ambiance without distraction\n- Long presentation segments\n\n### Normal Speed (1.0x)\n- Standard business presentations\n- Balanced, natural feel\n\n### Faster Speeds (1.2x - 3.0x)\n- Tech/startup presentations\n- Short, impactful segments\n- Modern, dynamic content\n\n## üìû Support\n\n- **Repository**: https://github.com/TundraTough-hub/arctic-presentation-template\n- **Issues**: Report problems via GitHub Issues\n\n---\n*Animation Speed: ${CONFIG.animationSpeed}x ‚Ä¢ Video FPS: ${CONFIG.fps} ‚Ä¢ Date: ${new Date().toISOString().split('T')[0]}*\n`;\n\n    fs.writeFileSync(path.join(CONFIG.outputDir, 'ANIMATION_SPEED_GUIDE.md'), guide);\n    console.log('üìñ Created animation speed control guide');\n  }\n\n  cleanup() {\n    try {\n      if (fs.existsSync(CONFIG.screenshotDir)) {\n        fs.removeSync(CONFIG.screenshotDir);\n      }\n    } catch (e) {\n      // Ignore cleanup errors\n    }\n  }\n\n  logTroubleshootingInfo() {\n    console.log('\\nüîß Animation Speed & Timing Troubleshooting:');\n    console.log('1. Video framerate always stays constant for smooth playback');\n    console.log('2. Animation speed affects CSS duration, not video framerate');\n    console.log('3. If animations appear wrong, try different speed values');\n    console.log('4. Ensure CSS animations have consistent timing functions');\n    console.log('5. Check that slide files exist and load properly');\n  }\n}\n\n// CLI interface with animation speed control\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  \n  if (args.includes('--help') || args.includes('-h')) {\n    console.log(`\nAnimation-Speed-Controlled Arctic Background Exporter\n\nUsage: node export-animation-accurate.js [options]\n\nOptions:\n  --resolution <res>     Export resolution (hd|fhd|uhd|presentation)\n  --quality <qual>       Video quality (low|medium|high|ultra)\n  --duration <sec>       Animation duration in seconds\n  --fps <rate>           Frame rate (15|24|30|60)\n  --speed <multiplier>   Animation speed (0.1-5.0, default: 1.0)\n  --classic-only         Export only classic style backgrounds\n  --modern-only          Export only modern style backgrounds\n  --help, -h            Show this help message\n\nAnimation Speed Examples:\n  --speed 0.5            Half speed (slower, more relaxed)\n  --speed 1.0            Normal speed (original timing)\n  --speed 2.0            Double speed (faster, more energetic)\n  --speed 0.25           Quarter speed (very slow, ambient)\n  --speed 3.0            Triple speed (very fast, dynamic)\n\nExamples:\n  node export-animation-accurate.js --speed 2.0 --resolution fhd\n  node export-animation-accurate.js --speed 0.5 --classic-only\n  node export-animation-accurate.js --speed 1.5 --quality ultra\n\nNote: Video framerate stays constant (smooth), only animation speed changes.\n`);\n    process.exit(0);\n  }\n\n  // Apply CLI options\n  const resolutionArg = args[args.indexOf('--resolution') + 1];\n  if (resolutionArg && CONFIG.resolutions[resolutionArg]) {\n    CONFIG.defaultResolution = resolutionArg;\n  }\n\n  const qualityArg = args[args.indexOf('--quality') + 1];\n  if (qualityArg && QUALITY_PRESETS[qualityArg]) {\n    CONFIG.quality = qualityArg;\n  }\n\n  const durationArg = args[args.indexOf('--duration') + 1];\n  if (durationArg && !isNaN(durationArg)) {\n    CONFIG.duration = parseInt(durationArg) * 1000;\n  }\n\n  const fpsArg = args[args.indexOf('--fps') + 1];\n  if (fpsArg && !isNaN(fpsArg)) {\n    CONFIG.fps = parseInt(fpsArg);\n    CONFIG.frameInterval = 1000 / CONFIG.fps;\n  }\n\n  // Animation speed control\n  const speedArg = args[args.indexOf('--speed') + 1];\n  if (speedArg && !isNaN(speedArg)) {\n    const speed = parseFloat(speedArg);\n    if (speed >= 0.1 && speed <= 5.0) {\n      CONFIG.animationSpeed = speed;\n    } else {\n      console.log('‚ö†Ô∏è  Animation speed must be between 0.1 and 5.0');\n      console.log('   Using default speed: 1.0x');\n    }\n  }\n\n  // Run the exporter\n  const exporter = new AnimationAccurateExporter();\n  \n  // Filter slides if requested\n  if (args.includes('--classic-only')) {\n    exporter.slides = exporter.slides.filter(s => s.category === 'classic');\n  } else if (args.includes('--modern-only')) {\n    exporter.slides = exporter.slides.filter(s => s.category === 'modern');\n  }\n\n  exporter.exportAllBackgrounds().catch(console.error);\n}\n\nmodule.exports = AnimationAccurateExporter;"